---
import { categoryIcons } from '../data/categoryIcons';

interface Props {
  categories?: string[];
}

const { categories = [
  "AI å·¥å…·",
  "æœç´¢å·¥å…·",
  "ä¸‹è½½å·¥å…·",
  "è§†é¢‘å¹³å°",
  "SEO å·¥å…·",
  "è®¾è®¡èµ„æº",
  "å‰ç«¯èµ„æº"
]} = Astro.props;
---

<div class="w-full max-w-2xl mx-auto relative mb-12">
  <div class="relative">
    <!-- æœç´¢å›¾æ ‡ -->
    <div class="absolute inset-y-0 left-0 flex items-center pl-4 pointer-events-none">
      <svg class="w-6 h-6 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
      </svg>
    </div>

    <!-- æœç´¢è¾“å…¥æ¡† -->
    <input 
      type="text" 
      id="search-input" 
      class="w-full py-4 pl-12 pr-12 text-lg text-gray-700 bg-white border border-gray-200 rounded-full dark:bg-gray-800 dark:text-gray-300 dark:border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 shadow-md"
      placeholder="æœç´¢å·¥å…·åç§°ã€æè¿°ã€åˆ†ç±»æˆ–æ ‡ç­¾..."
      autocomplete="off"
    />

    <!-- æ¸…é™¤æŒ‰é’® -->
    <button 
      id="clear-search" 
      class="absolute inset-y-0 right-0 flex items-center pr-4 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 hidden"
      aria-label="æ¸…é™¤æœç´¢"
    >
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
      </svg>
    </button>
  </div>
  
  <!-- åˆ†ç±»è¿‡æ»¤å™¨ -->
  <div class="flex flex-wrap gap-2 mt-4 justify-center">
    <button
      class="category-filter active px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
      data-category="all"
    >
      <span class="mr-1">ğŸ“¦</span> å…¨éƒ¨
    </button>
    {categories.map(category => (
      <button
        class="category-filter px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-700 dark:bg-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
        data-category={category}
      >
        <span class="mr-1">{categoryIcons[category] || "ğŸ“¦"}</span> {category}
      </button>
    ))}
  </div>
</div>

<script>
  let debounceTimer: number;

  document.addEventListener('DOMContentLoaded', () => {
    const searchInput = document.getElementById('search-input') as HTMLInputElement;
    const clearButton = document.getElementById('clear-search');
    const categoryFilters = document.querySelectorAll('.category-filter');
    const toolsContainer = document.getElementById('tools-container');
    const noResultsMessage = document.getElementById('no-results-message');
    let currentCategory = 'all';
    
    // ç¡®ä¿æ— ç»“æœæ¶ˆæ¯åœ¨åˆå§‹åŒ–æ—¶éšè—
    if (noResultsMessage) {
      noResultsMessage.classList.add('hidden');
      noResultsMessage.style.display = 'none';
    }
    
    // é˜²æŠ–å‡½æ•°
    const debounce = (func: Function, delay: number) => {
      return (...args: any[]) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => func(...args), delay);
      };
    };

    // è·å–æ‰€æœ‰å·¥å…·å¡ç‰‡
    const toolCards = document.querySelectorAll('.tool-card-container');
    console.log('æ‰¾åˆ°å·¥å…·å¡ç‰‡æ•°é‡:', toolCards.length);
    
    // è·å–æ‰€æœ‰åˆ†ç±»å®¹å™¨
    const categoryContainers = document.querySelectorAll('.category-container');
    console.log('æ‰¾åˆ°åˆ†ç±»å®¹å™¨æ•°é‡:', categoryContainers.length);
    
    const toggleClearButton = () => {
      if (searchInput.value) {
        clearButton?.classList.remove('hidden');
      } else {
        clearButton?.classList.add('hidden');
      }
    };

    const updateVisibility = (visibleCount: number, searchTerm: string) => {
      // æ£€æŸ¥æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
      //const isMobile = window.innerWidth < 768;
      
      // æ›´æ–°å·¥å…·å®¹å™¨çš„å¯è§æ€§
      if (toolsContainer) {
        toolsContainer.style.display = visibleCount === 0 && searchTerm !== '' ? 'none' : 'block';
      }
      
      // æ›´æ–°æ— ç»“æœæ¶ˆæ¯çš„å¯è§æ€§
      if (noResultsMessage) {
        if (visibleCount === 0 && searchTerm !== '') {
          noResultsMessage.classList.remove('hidden');
          noResultsMessage.style.display = 'flex';
        } else {
          noResultsMessage.classList.add('hidden');
          noResultsMessage.style.display = 'none';
        }
      }
      
      // å¤„ç†åˆ†ç±»å®¹å™¨çš„æ˜¾ç¤º/éšè—
      categoryContainers.forEach(container => {
        const cards = container.querySelectorAll('.tool-card-container');
        let hasVisibleCards = false;
        
        cards.forEach(card => {
          if ((card as HTMLElement).style.display !== 'none') {
            hasVisibleCards = true;
          }
        });
        
        if (!hasVisibleCards) {
          (container as HTMLElement).style.display = 'none';
        } else {
          (container as HTMLElement).style.display = 'block';
        }
         
      });
    };
    
    const performSearch = () => {
      const searchTerm = searchInput.value.trim().toLowerCase();
      let visibleCount = 0;
      
      console.log('æ‰§è¡Œæœç´¢ï¼Œå…³é”®è¯:', searchTerm, 'å½“å‰åˆ†ç±»:', currentCategory);
      
      toolCards.forEach((card) => {
        const toolName = card.getAttribute('data-name')?.toLowerCase() || '';
        const toolDescription = card.getAttribute('data-description')?.toLowerCase() || '';
        const toolCategory = card.getAttribute('data-category')?.toLowerCase() || '';
        const toolTags = card.getAttribute('data-tags')?.toLowerCase() || '';
        
        console.log('æ£€æŸ¥å¡ç‰‡:', toolName, 'æè¿°:', toolDescription, 'åˆ†ç±»:', toolCategory, 'æ ‡ç­¾:', toolTags);
        
        const matchesSearch = searchTerm === '' || 
          toolName.includes(searchTerm) || 
          toolDescription.includes(searchTerm) || 
          toolCategory.includes(searchTerm) ||
          toolTags.includes(searchTerm);
          
        const matchesCategory = currentCategory === 'all' || toolCategory === currentCategory.toLowerCase();
        
        const isVisible = matchesSearch && matchesCategory;
        (card as HTMLElement).style.display = isVisible ? 'block' : 'none';
        
        if (isVisible) visibleCount++;
      });
      
      console.log('æœç´¢ç»“æœ: æ‰¾åˆ°', visibleCount, 'ä¸ªåŒ¹é…é¡¹');
      
      updateVisibility(visibleCount, searchTerm);
    };
    
    const clearSearch = () => {
      searchInput.value = '';
      clearButton?.classList.add('hidden');
      performSearch();
      searchInput.focus(); // æ¸…é™¤åé‡æ–°èšç„¦åˆ°æœç´¢æ¡†
    };
    
    // åˆ†ç±»è¿‡æ»¤å™¨å¤„ç†
    categoryFilters.forEach(filter => {
      filter.addEventListener('click', () => {
        categoryFilters.forEach(f => f.classList.remove('active'));
        filter.classList.add('active');
        currentCategory = filter.getAttribute('data-category') || 'all';
        performSearch();
      });
    });
    
    // æœç´¢æ¡†è¾“å…¥äº‹ä»¶ï¼ˆå¸¦é˜²æŠ–ï¼‰
    searchInput.addEventListener('input', debounce(() => {
      toggleClearButton();
      performSearch();
    }, 300));
    
    // æ¸…é™¤æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    clearButton?.addEventListener('click', clearSearch);
    
    // æŒ‰ä¸‹ Esc é”®æ¸…é™¤æœç´¢
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        clearSearch();
      }
    });
    
    // ç›‘å¬çª—å£å¤§å°å˜åŒ–
    window.addEventListener('resize', debounce(() => {
      performSearch();
    }, 300));
    
    // åˆå§‹åŒ–
    toggleClearButton();
    performSearch();
  });
</script>

<style>
  .category-filter.active {
    @apply bg-blue-500 text-white hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700;
  }

  /* æœç´¢æ¡†åŠ¨ç”»æ•ˆæœ */
  #search-input {
    transition: all 0.2s ease-in-out;
  }

  #search-input:focus {
    transform: scale(1.01);
  }
</style>
